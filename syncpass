#!/bin/bash
check_dns_tools() {                                         if command -v drill >/dev/null 2>&1; then
        DNS_TOOL="drill"                                        return 0
    elif command -v dig >/dev/null 2>&1; then
        DNS_TOOL="dig"
        return 0
    else                                                        echo "> Error: Neither 'drill' nor 'dig' found. Please install ldns or bind-utils." >&2
        exit 1
    fi                                                  }
imp() {
    local path=$1
    if [ -f $path ]; then
        set -a
        source $path
        set +a
    fi
}
### env vars ###
imp ".env"
if [[ -n $DDNS_DOMAIN ]]; then
    check_dns_tools
    case "$DNS_TOOL" in
        drill)
	    IP_ADDRESS=$(drill "$DDNS_DOMAIN" | awk '/^[^;].*IN.*A/ {print $5; exit}')
            ;;
        dig)
	    IP_ADDRESS=$(dig +short "$DDNS_DOMAIN")
            ;;
    esac
    echo -e "set ip: $IP_ADDRESS"
fi
imp "version"
imp "settings"


### imports ###

# func_init_local
imp "./utils/import_init"

# func_increment_version, func_print_settings
imp "./utils/import_settings"

# func_get_server_home_path
imp "./utils/import_ssh"


confirm() {
    if [[ -n "$1" ]]; then
        read -p "$1 (y/n): " -n 1 -r
        echo    # Move to new line
        [[ $REPLY =~ ^[Yy]$ ]]
    else
        read -p "Are you sure? (y/n): " -n 1 -r
        echo    # Move to new line
        [[ $REPLY =~ ^[Yy]$ ]]
    fi
}
case "$1" in
    init)
        func_init_local
        server_home_path=$(func_get_server_home_path)
        # check if server has syncpass
        # check if server has a password store linked already
        # pull server's password store, confrim before doing this
        # check if there is password store local already before pulling, back it up if there is.
        # back it up in current directory
        ;;
    *)
        ;;
esac

# settings check, return 1 if no settings avail

case "$1" in
    add|edit|generate|rm)
        # push new version to server after command is finished running
        if pass $@; then
            func_increment_version
            echo -e "✓ Local version updated"

            # update server's passwordstore
            func_update_server_passwordstore

            # update server's version
            curr_ver=$(func_get_local_version)
            func_update_server_version $curr_ver
            echo -e "✓ Server version updated"
        else
            echo -e "✗ pass command failed."
        fi
        ;;
    inject)
        func_update_server_passwordstore
        ;;
    help)
        func_print_settings
        ;;
    *)
        args=("$@")
        first_non_flag=""
        
        for arg in "${args[@]}"; do
            if [[ "$arg" != -* ]]; then
                first_non_flag="$arg"
                break
            fi
        done

        case "$first_non_flag" in
            ls|find|grep|insert|edit|generate|rm|mv|cp|git) return 1 ;;
            "") 
                echo -e "✗ Syncpass could not determine the pass command."
                exit 1
                ;;
            *)
                ## Probably trying to get password
                ### Sync server and local before running pass

                server_ver=$(func_get_server_version)

                echo "✓ SSH successful"

                if (( server_ver == VERSION )); then
                    echo -e "✓ Syncpass versions on server and local are synced."
                elif (( server_ver < VERSION ));then
                    echo -e ">>> WARNING: Local version is ahead of server"
                    echo -e ">>> Recommending to run 'syncpass sync'"
                else
                    echo -e "✗ Local .password-store is behind server, preparing to update"
                    if confirm "> Are you sure you want to overwrite/update your local .password-store with the one from the server?"; then
                        echo -e ">>> Preparing to update your local password-store ..."
                    else
                        echo -e "> Exiting syncpass, no changes have been made."
                        exit 1
                    fi

                    # backup local .password-store
                    sp_filename="${C_PATH}/.password-store_backup.tar.gz"
                    if cd $HOME && tar -czf $sp_filename .password-store; then
                        echo -e "✓ Backed up local ~/.password-store to .password-store_backup.tar.gz"
                    else
                        echo -e "✗ tar command for backing up failed."
                        exit 1
                    fi

                    # pull password-store from server
                    func_get_server_passwordstore

                    # unzip it to local
                fi

                pass $@ 2>&1
                exit_code=$?

                if [ $exit_code -ne 0 ]; then
                    echo -e "✗ pass command failed."
                fi
                exit 0
                ;;
        esac

        if [[ -n "$1" ]]; then
            folder=$1

            server_ver=$(func_get_server_version)

            if (( server_ver == VERSION )); then
                echo -e ">>> Syncpass versions on server and local are synced. \n"
            elif (( server_ver < VERSION ));then
                echo -e ">>> Local version is ahead of server \n"
                echo -e ">>> Syncpass versions on server and local are unsynced, updating ...\n"
            else
                echo -e ">>> Local version is behind server, preparing to update ...\n"
                # backup local to a _backup_timestamp.tar.gz
                sp_filename="${C_PATH}/.password-store_backup.tar.gz"
                compressed_zip=$(cd $HOME && tar -czf $sp_filename .password-store)
                echo -e ">>> Backed up local ~/.password-store to .password-store_backup.tar.gz"
            fi

            if password=$(pass show "$folder" 2>/dev/null); then
                echo $password
            else
                echo -e "> Failed to retrieve password for '$folder'"
                exit 1
            fi

        elif [ $# -eq 0 ]; then
            pass
        fi
        ;;
esac
